package actions

import (
	"fmt"
	"github.com/gobuffalo/buffalo"
	"github.com/gobuffalo/nulls"
	"github.com/gobuffalo/pop"
)

// This file is generated by Buffalo. It offers a basic structure for
// adding, editing and deleting a page. If your model is more
// complex or you need more than the basic implementation you need to
// edit this file.

// Following naming logic is implemented in Buffalo:
// Model: Singular (Song)
// DB Table: Plural (songs)
// Resource: Plural (Songs)
// Path: Plural (/songs)
// View Template Folder: Plural (/templates/songs/)

// SongsResource is the resource for the Song model
type SongsResource struct {
	buffalo.Resource
}

type Song struct {
	Id         int          `json:"id"`
	Name       string       `json:"name"`
	Content    string       `json:"content"`
	Slug       string       `json:"slug"`
	Rhythm     nulls.String       `json:"rhythm"`
	SingerName string       `json:"singerName"`
	SingerSlug string       `json:"singerSlug"`
	SeoContent string       `json:"seoContent"`
	Tone       string       `json:"tone"`
}

type ShortSong struct {
	Id         int    `json:"id"`
	Name       string `json:"name"`
	Slug       string `json:"slug"`
	SingerName string `json:"singerName"`
	SingerSlug string `json:"singerSlug"`
}

// GET /songs
func (v SongsResource) List(c buffalo.Context) error {

	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return fmt.Errorf("no transaction found")
	}

	songs := []ShortSong{}

	// Default values are "page=1" and "per_page=20".
	//q := tx.PaginateFromParams(c.Params())

	q := tx.RawQuery("SELECT song.id, song.name, song.slug, singer.name as singername, singer.slug as singerslug" +
		" FROM songs as song, singers as singer" +
		" WHERE song.singer_id = singer.id")

	err := q.All(&songs)
	if err != nil {
		return c.Error(404, err)
	}

	c.Set("pagination", q.Paginator)

	return c.Render(200, r.JSON(&songs))
}

// the path GET /songs/{song_id}
func (v SongsResource) Show(c buffalo.Context) error {

	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return fmt.Errorf("no transaction found")
	}

	song := &Song{}

	q := tx.RawQuery("SELECT song.id, song.name, song.raw_content as content, song.slug, song.rhythm, singer.name as singername, "+
		" singer.slug as singerslug, seo.content as seocontent, song.tone as tone"+
		" FROM songs as song, singers as singer, seo_contents as seo "+
		" WHERE song.slug = ? and song.singer_id = singer.id and song.seo_id = seo.id", c.Param("slug"))

	if err := q.Find(song, c.Param("slug")); err != nil {
		return c.Error(404, err)
	}

	return c.Render(200, r.JSON(&song))
}
